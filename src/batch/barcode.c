/* This is a copy of eansrc.c                                   */
/* DPC Notes                                                    */
/*    1. This routine is linked in with the following programs: */
/*            ISBARCDE.cbl                                      */
/*                                                              */
/*    2. Modifications made to work with COBOL. (F 'DPC MOD')   */
/*--------------------------------------------------------------*/
/*           BAR CODE PRINT PROGRAM - SOURCE CODE FILE          */              
/*--------------------------------------------------------------*/              
/*                                                              */              
/* TRANSLATED FROM PL/I TO C                                    */              
/*                                                              */              
/*--------------------------------------------------------------*/              
/*                   PL/I ORIGINAL COMMENT                      */              
/*--------------------------------------------------------------*/              
/* VERSION 1    RELEASE 1  MODIFICATION LEVEL 1                 */              
/*                                                              */              
/* LAST MODIFICATION DATE: 1989/10/17                           */              
/*                                                              */              
/*--------------------------------------------------------------*/              
/* DESCRIPTION:                                                 */              
/* GIVEN THE THREE INPUTS DESCRIBED BELOW, THE SUBROUTINE       */              
/* CALCULATES A STRING OF CODE POINTS WHICH, WHEN PRINTED WITH  */              
/* THE BAR CODE FONT, WILL GENERATE THE BAR CODE.               */              
/*                                                              */              
/* OUTPUT IS RETURNED IN THREE FIELDS.  THE 'INPUT' FIELD HAS   */              
/* THE CHARACTERS WHICH WERE ENCODED IN THE BAR CODE.  THIS     */              
/* INCLUDES THE CHECK DIGIT AND THE CONVERSION OF SPACES TO     */              
/* ZEROS.                                                       */              
/*                                                              */              
/* THE 'SIZE' FIELD CONTAINS THE LENGTH OF THE OUTPUT STRING    */              
/* RETURNED TO THE CALLER.  IF THE LENGTH IS 128 AND THE FIRST  */              
/* FIVE CHARACTERS OF THE OUTPUT STRING ARE 'ERROR' THEN AN     */              
/* ERROR OCCURRED.  ERRORS MUST BE HANDLED BY THE CALLING       */              
/* PROCEDURE.                                                   */              
/*                                                              */              
/* THE 'OUTPUT' FIELD CONTAINS THE STRING OF CODE POINTS WHICH, */              
/* WHEN PRINTED WITH THE BAR CODE FONT, WILL GENERATE THE BAR   */              
/* CODE.  IF AN ERROR OCCURRED, THIS OUTPUT STRING WILL CONTAIN */              
/* AN ERROR MESSAGE FOR THE CALLING PROGRAM.                    */              
/*--------------------------------------------------------------*/              
/*                                                              */              
/* INPUT TO SUBROUTINE:                                         */              
/*     BARCODE:         'E' or ' ' -- EAN 8 or 13               */              
/*     CHAR(1)          'I'        -- INTERLEAVED 2 of 5 HIGH D */              
/*                      'B'        -- INTERLEAVED 2 of 5 LOW D  */              
/*                      'A'        -- INDUSTRIAL                */              
/*                      'T'        -- MATRIX 2 OF 5             */              
/*                      '3'        -- 3 OF 9 HIGH D             */              
/*                      '6'        -- 3 OF 9 LOW D              */              
/*                      'M'        -- MSI                       */              
/*                      'U'        -- UPC A                     */              
/*                      'V'        -- UPC E                     */              
/*                      'W'        -- UPC E Number System 1     */              
/*                      'C'        -- Code 128                  */              
/*                                                              */              
/*     INPUT:           'E' or ' ' -- 7,8,12,or 13 digits       */              
/*     CHAR(40)         'I'        -- Max. 40 digits            */              
/*                      'B'        -- Max. 20 digits            */              
/*                      'A'        -- Max. 35 digits            */              
/*                      'T'        -- Max. 35 digits            */              
/*                      '3'        -- Max. 30 characters        */              
/*                      '6'        -- Max. 14 characters        */              
/*                      'M'        -- Max. 15 digits            */              
/*                      'U'        -- 11 digits                 */              
/*                      'V'        -- 11 digits                 */              
/*                      'W'        -- 6  digits                 */              
/*                      'C'        -- Max. 28 characters        */              
/*                                                              */              
/*     SIZE:            LENGTH OF INPUT STRING                  */              
/*     BIN FIXED(15) ALIGNED                                    */              
/*                                                              */              
/* OUTPUT OF SUBROUTINE:                                        */              
/*     OUTPUT:          UP TO 128 SPECIAL CHARS                 */              
/*     CHAR(128)        (15 PITCH)                              */              
/*                                                              */              
/*  CHANGES:                                                    */              
/*     @001 - ADDITION OF UPC E NUMBER SYSTEM 1 SUPPORT         */              
/*                                                              */              
/*--------------------------------------------------------------*/              
                                                                                
/*-----------------------------------------------------------------------*/     
/*                                Headers                                */     
/*-----------------------------------------------------------------------*/     
                                                                                
#include <ctype.h>              /* toupper() */                                 
#include <stddef.h>             /* NULL */                                      
#include <stdlib.h>             /* div_t, div(), _itoa() */                     
#include <string.h>             /* strlen(), strcat(), strcpy() */              
                                                                                
#ifdef __FOXPRO__                                                               
  #include <pro_ext.h>          /* interface FoxPro/C */                        
#endif                                                                          
                                                                                
#include "bcsubr.h"                                                             
                                                                                
/*-----------------------------------------------------------------------*/     
/*                                 Macros                                */     
/*-----------------------------------------------------------------------*/     
                                                                                
/* Convert a character to an integer value                   */                 
#define CTOI( c )               ( (int) ( ( c ) - '0' ) )                       
/* Convert an integer to a printable character               */                 
#define ITOC( i )               ( (char) ( ( i ) + '0' ) )                      
/* return the count of the elements in an array  */                             
#define ASIZE( a )              ( sizeof( a ) / sizeof( a[0] ) )                
                                                                                
#ifndef _itoa                                                                   
  #ifdef itoa                                                                   
    #define _itoa( i, s, n )    itoa( i, s, n )                                 
  #endif                                                                        
#endif                                                                          
                                                                                
/*-----------------------------------------------------------------------*/     
/*                        Prototypes of functions                        */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void initialize( void );                                                 
static void eancl( int narrsize );                                              
static void upc( int upctype, int narrsize );                                   
static void upcenum1( int narrsize );                                           
static void srean13( void );                                                    
static void sre8ua( int numhalf );                                              
static void srupce( char *data, int num_system );                               
static int  zerosupp( char *data );                                             
static void x6to11( char *in6 );                                                
static void convert( char *strbars, char *strspcs, char *dest );                
static void itf( int varsize, int narrsize, int widesize );                     
static void sritf( void );                                                      
static void indcl( int btype, int narrsize, int widesize );                     
static void srind( int btype );                                                 
static void codmsi( int narrsize, int widesize );                               
static void srmsi( void );                                                      
static void cod39( int varsize, int narrsize, int widesize );                   
static void srcod39( void );                                                    
static void code128( int narrsize );                                            
static void srcod128( void );                                                   
static void appg( void );                                                       
static void codea( void );                                                      
static void codeb( void );                                                      
static void codec( void );                                                      
static int  match( char *test, char *string, int lenstring,                     
                   int start, int finish );                                     
static int  nextsp( int start, int stop );                                      
static int  numdigits( void );                                                  
static void insert( int patternum );                                            
static void prochar( char *ttable, int ttablelen );                             
static void checksr( int weight );                                              
static int  validate( char *valchars, int codeflag );                           
static void srconv( void );                                                     
static void genbin( char *encoding, int encodlen, int spcvalue );               
static void errmsg( int inum, char ch );                                        
static char *_itoa( int n, char *str, int base );                               
static char *translate( char *trans, int len, char after, char before );        
static int  verify( char *check, int checklen, char *src, int srclen );         
static int  ch_index( char *buf, char c, int count );                           
                                                                                
/*-----------------------------------------------------------------------*/     
/*                           Global variables                            */     
/*-----------------------------------------------------------------------*/     
                                                                                
static char *coibm = "S544-3190 (c) COPYRIGHT "                                 
       "INTERNATIONAL BUSINESS MACHINES CORPORATION 1988, 1997";                
                                                                                
/* Arrays with the encoding for each type of bar code */                        
static char numsets[3][10][4] = {                                               
    /* Initialize EAN/UPC number set A (left odd) encodings */                  
    { { '2', '1', '0', '0' },       /* 0 */                                     
      { '1', '1', '1', '0' },       /* 1 */                                     
      { '1', '0', '1', '1' },       /* 2 */                                     
      { '0', '3', '0', '0' },       /* 3 */                                     
      { '0', '0', '2', '1' },       /* 4 */                                     
      { '0', '1', '2', '0' },       /* 5 */                                     
      { '0', '0', '0', '3' },       /* 6 */                                     
      { '0', '2', '0', '1' },       /* 7 */                                     
      { '0', '1', '0', '2' },       /* 8 */                                     
      { '2', '0', '0', '1' } },     /* 9 */                                     
    /* Initialize EAN/UPC number set B (left even) encodings */                 
    { { '0', '0', '1', '2' },       /* 0 */                                     
      { '0', '1', '1', '1' },       /* 1 */                                     
      { '1', '1', '0', '1' },       /* 2 */                                     
      { '0', '0', '3', '0' },       /* 3 */                                     
      { '1', '2', '0', '0' },       /* 4 */                                     
      { '0', '2', '1', '0' },       /* 5 */                                     
      { '3', '0', '0', '0' },       /* 6 */                                     
      { '1', '0', '2', '0' },       /* 7 */                                     
      { '2', '0', '1', '0' },       /* 8 */                                     
      { '1', '0', '0', '2' } },     /* 9 */                                     
    /* Initialize EAN/UPC number set C (right) encodings */                     
    { { '2', '1', '0', '0' },       /* 0 */                                     
      { '1', '1', '1', '0' },       /* 1 */                                     
      { '1', '0', '1', '1' },       /* 2 */                                     
      { '0', '3', '0', '0' },       /* 3 */                                     
      { '0', '0', '2', '1' },       /* 4 */                                     
      { '0', '1', '2', '0' },       /* 5 */                                     
      { '0', '0', '0', '3' },       /* 6 */                                     
      { '0', '2', '0', '1' },       /* 7 */                                     
      { '0', '1', '0', '2' },       /* 8 */                                     
      { '2', '0', '0', '1' } } };   /* 9 */                                     
                                                                                
static char parity13[10][6] = {                                                 
    /* Initialize parity pattern array for EAN 13 */                            
    { '0', '0', '0', '0', '0', '0' },   /* FOR THESE PARITY PATTERNS:       */  
    { '0', '0', '1', '0', '1', '1' },   /*   0 -> NUMBER SET EAN: A         */  
    { '0', '0', '1', '1', '0', '1' },   /*        NUMBER SET UPC: LEFT ODD  */  
    { '0', '0', '1', '1', '1', '0' },   /*   1 -> NUMBER SET EAN: B         */  
    { '0', '1', '0', '0', '1', '1' },   /*        NUMBER SET UPC: LEFT EVEN */  
    { '0', '1', '1', '0', '0', '1' },                                           
    { '0', '1', '1', '1', '0', '0' },                                           
    { '0', '1', '0', '1', '0', '1' },                                           
    { '0', '1', '0', '1', '1', '0' },                                           
    { '0', '1', '1', '0', '1', '0' } };                                         
                                            /* @001 from here to next  */       
static char parityE[2][10][6] = {                                               
    /* Initialize parity pattern array for UPC E number system 0 */             
    { { '1', '1', '1', '0', '0', '0' },     /* FOR THESE PARITY PATTERNS:       
*/                                                                              
      { '1', '1', '0', '1', '0', '0' },     /*   0 -> NUMBER SET UPC: LEFT ODD  
*/                                                                              
      { '1', '1', '0', '0', '1', '0' },     /*   1 -> NUMBER SET UPC: LEFT EVEN 
*/                                                                              
      { '1', '1', '0', '0', '0', '1' },                                         
      { '1', '0', '1', '1', '0', '0' },                                         
      { '1', '0', '0', '1', '1', '0' },                                         
      { '1', '0', '0', '0', '1', '1' },                                         
      { '1', '0', '1', '0', '1', '0' },                                         
      { '1', '0', '1', '0', '0', '1' },                                         
      { '1', '0', '0', '1', '0', '1' } },                                       
    /* Initialize parity pattern array for UPC E number system 1  */            
    { { '0', '0', '0', '1', '1', '1' },     /* FOR THESE PARITY PATTERNS:       
*/                                                                              
      { '0', '0', '1', '0', '1', '1' },     /*   0 -> NUMBER SET UPC: LEFT ODD  
*/                                                                              
      { '0', '0', '1', '1', '0', '1' },     /*   1 -> NUMBER SET UPC: LEFT EVEN 
*/                                                                              
      { '0', '0', '1', '1', '1', '0' },                                         
      { '0', '1', '0', '0', '1', '1' },                                         
      { '0', '1', '1', '0', '0', '1' },                                         
      { '0', '1', '1', '1', '0', '0' },                                         
      { '0', '1', '0', '1', '0', '1' },                                         
      { '0', '1', '0', '1', '1', '0' },                                         
      { '0', '1', '1', '0', '1', '0' } } };                                     
                                            /* @001 end of changes     */       
static char br25[10][5] = {                                                     
    /* Initialize two of five encodings */                                      
    { '0', '0', '1', '1', '0' },            /* ZERO */                          
    { '1', '0', '0', '0', '1' },                                                
    { '0', '1', '0', '0', '1' },                                                
    { '1', '1', '0', '0', '0' },                                                
    { '0', '0', '1', '0', '1' },                                                
    { '1', '0', '1', '0', '0' },                                                
    { '0', '1', '1', '0', '0' },                                                
    { '0', '0', '0', '1', '1' },                                                
    { '1', '0', '0', '1', '0' },                                                
    { '0', '1', '0', '1', '0' } };                                              
                                                                                
static char msibr[10][8] = {                                                    
    /* Initialize MSI encodings */                                              
    { '0', '1', '0', '1', '0', '1', '0', '1' },     /* ZERO */                  
    { '0', '1', '0', '1', '0', '1', '1', '0' },                                 
    { '0', '1', '0', '1', '1', '0', '0', '1' },                                 
    { '0', '1', '0', '1', '1', '0', '1', '0' },                                 
    { '0', '1', '1', '0', '0', '1', '0', '1' },                                 
    { '0', '1', '1', '0', '0', '1', '1', '0' },                                 
    { '0', '1', '1', '0', '1', '0', '0', '1' },                                 
    { '0', '1', '1', '0', '1', '0', '1', '0' },                                 
    { '1', '0', '0', '1', '0', '1', '0', '1' },                                 
    { '1', '0', '0', '1', '0', '1', '1', '0' } };                               
                                                                                
static char c39br[44][9] = {                                                    
    /* Initialize the 3 of 9 encoding table */                                  
    { '1', '0', '0', '1', '0', '0', '0', '0', '1' },    /* '1' */               
    { '0', '0', '1', '1', '0', '0', '0', '0', '1' },    /* '2' */               
    { '1', '0', '1', '1', '0', '0', '0', '0', '0' },    /* '3' */               
    { '0', '0', '0', '1', '1', '0', '0', '0', '1' },    /* '4' */               
    { '1', '0', '0', '1', '1', '0', '0', '0', '0' },    /* '5' */               
    { '0', '0', '1', '1', '1', '0', '0', '0', '0' },    /* '6' */               
    { '0', '0', '0', '1', '0', '0', '1', '0', '1' },    /* '7' */               
    { '1', '0', '0', '1', '0', '0', '1', '0', '0' },    /* '8' */               
    { '0', '0', '1', '1', '0', '0', '1', '0', '0' },    /* '9' */               
    { '0', '0', '0', '1', '1', '0', '1', '0', '0' },    /* '0' */               
                                                                                
    { '1', '0', '0', '0', '0', '1', '0', '0', '1' },    /* 'A' */               
    { '0', '0', '1', '0', '0', '1', '0', '0', '1' },    /* 'B' */               
    { '1', '0', '1', '0', '0', '1', '0', '0', '0' },    /* 'C' */               
    { '0', '0', '0', '0', '1', '1', '0', '0', '1' },    /* 'D' */               
    { '1', '0', '0', '0', '1', '1', '0', '0', '0' },    /* 'E' */               
    { '0', '0', '1', '0', '1', '1', '0', '0', '0' },    /* 'F' */               
    { '0', '0', '0', '0', '0', '1', '1', '0', '1' },    /* 'G' */               
    { '1', '0', '0', '0', '0', '1', '1', '0', '0' },    /* 'H' */               
    { '0', '0', '1', '0', '0', '1', '1', '0', '0' },    /* 'I' */               
    { '0', '0', '0', '0', '1', '1', '1', '0', '0' },    /* 'J' */               
                                                                                
    { '1', '0', '0', '0', '0', '0', '0', '1', '1' },    /* 'K' */               
    { '0', '0', '1', '0', '0', '0', '0', '1', '1' },    /* 'L' */               
    { '1', '0', '1', '0', '0', '0', '0', '1', '0' },    /* 'M' */               
    { '0', '0', '0', '0', '1', '0', '0', '1', '1' },    /* 'N' */               
    { '1', '0', '0', '0', '1', '0', '0', '1', '0' },    /* 'O' */               
    { '0', '0', '1', '0', '1', '0', '0', '1', '0' },    /* 'P' */               
    { '0', '0', '0', '0', '0', '0', '1', '1', '1' },    /* 'Q' */               
    { '1', '0', '0', '0', '0', '0', '1', '1', '0' },    /* 'R' */               
    { '0', '0', '1', '0', '0', '0', '1', '1', '0' },    /* 'S' */               
    { '0', '0', '0', '0', '1', '0', '1', '1', '0' },    /* 'T' */               
                                                                                
    { '1', '1', '0', '0', '0', '0', '0', '0', '1' },    /* 'U' */               
    { '0', '1', '1', '0', '0', '0', '0', '0', '1' },    /* 'V' */               
    { '1', '1', '1', '0', '0', '0', '0', '0', '0' },    /* 'W' */               
    { '0', '1', '0', '0', '1', '0', '0', '0', '1' },    /* 'X' */               
    { '1', '1', '0', '0', '1', '0', '0', '0', '0' },    /* 'Y' */               
    { '0', '1', '1', '0', '1', '0', '0', '0', '0' },    /* 'Z' */               
    { '0', '1', '0', '0', '0', '0', '1', '0', '1' },    /* '-' */               
    { '1', '1', '0', '0', '0', '0', '1', '0', '0' },    /* '.' */               
    { '0', '1', '1', '0', '0', '0', '1', '0', '0' },    /* ' ' */               
    { '0', '1', '0', '1', '0', '1', '0', '0', '0' },    /* '$' */               
                                                                                
    { '0', '1', '0', '1', '0', '0', '0', '1', '0' },    /* '/' */               
    { '0', '1', '0', '0', '0', '1', '0', '1', '0' },    /* '+' */               
    { '0', '0', '0', '1', '0', '1', '0', '1', '0' },    /* '%' */               
    { '0', '1', '0', '0', '1', '0', '1', '0', '0' } };  /* COMPLETENESS */      
/* '*' */                                                                       
                                                                                
static char c128br[106][6] = {                                                  
    /* Initialize the code 128 encoding table */                                
    { '1', '0', '1', '1', '1', '1' },       /* ' ' */                           
    { '1', '1', '1', '0', '1', '1' },       /* '!' */                           
    { '1', '1', '1', '1', '1', '0' },       /* '"' */                           
    { '0', '1', '0', '1', '1', '2' },       /* '#' */                           
    { '0', '1', '0', '2', '1', '1' },       /* '$' */                           
    { '0', '2', '0', '1', '1', '1' },       /* '%' */                           
    { '0', '1', '1', '1', '0', '2' },       /* '&' */                           
    { '0', '1', '1', '2', '0', '1' },       /* ''' */                           
    { '0', '2', '1', '1', '0', '1' },       /* '(' */                           
    { '1', '1', '0', '1', '0', '2' },       /* ')' */                           
                                                                                
    { '1', '1', '0', '2', '0', '1' },       /* '*' */                           
    { '1', '2', '0', '1', '0', '1' },       /* '+' */                           
    { '0', '0', '1', '1', '2', '1' },       /* ',' */                           
    { '0', '1', '1', '0', '2', '1' },       /* '-' */                           
    { '0', '1', '1', '1', '2', '0' },       /* '.' */                           
    { '0', '0', '2', '1', '1', '1' },       /* '/' */                           
    { '0', '1', '2', '0', '1', '1' },       /* '0' */                           
    { '0', '1', '2', '1', '1', '0' },       /* '1' */                           
    { '1', '1', '2', '1', '0', '0' },       /* '2' */                           
    { '1', '1', '0', '0', '2', '1' },       /* '3' */                           
                                                                                
    { '1', '1', '0', '1', '2', '0' },       /* '4' */                           
    { '1', '0', '2', '1', '0', '1' },       /* '5' */                           
    { '1', '1', '2', '0', '0', '1' },       /* '6' */                           
    { '2', '0', '1', '0', '2', '0' },       /* '7' */                           
    { '2', '0', '0', '1', '1', '1' },       /* '8' */                           
    { '2', '1', '0', '0', '1', '1' },       /* '9' */                           
    { '2', '1', '0', '1', '1', '0' },       /* ':' */                           
    { '2', '0', '1', '1', '0', '1' },       /* ';' */                           
    { '2', '1', '1', '0', '0', '1' },       /* '<' */                           
    { '2', '1', '1', '1', '0', '0' },       /* '=' */                           
                                                                                
    { '1', '0', '1', '0', '1', '2' },       /* '>' */                           
    { '1', '0', '1', '2', '1', '0' },       /* '?' */                           
    { '1', '2', '1', '0', '1', '0' },       /* '@' */                           
    { '0', '0', '0', '2', '1', '2' },       /* 'A' */                           
    { '0', '2', '0', '0', '1', '2' },       /* 'B' */                           
    { '0', '2', '0', '2', '1', '0' },       /* 'C' */                           
    { '0', '0', '1', '2', '0', '2' },       /* 'D' */                           
    { '0', '2', '1', '0', '0', '2' },       /* 'E' */                           
    { '0', '2', '1', '2', '0', '0' },       /* 'F' */                           
    { '1', '0', '0', '2', '0', '2' },       /* 'G' */                           
                                                                                
    { '1', '2', '0', '0', '0', '2' },       /* 'H' */                           
    { '1', '2', '0', '2', '0', '0' },       /* 'I' */                           
    { '0', '0', '1', '0', '2', '2' },       /* 'J' */                           
    { '0', '0', '1', '2', '2', '0' },       /* 'K' */                           
    { '0', '2', '1', '0', '2', '0' },       /* 'L' */                           
    { '0', '0', '2', '0', '1', '2' },       /* 'M' */                           
    { '0', '0', '2', '2', '1', '0' },       /* 'N' */                           
    { '0', '2', '2', '0', '1', '0' },       /* 'O' */                           
    { '2', '0', '2', '0', '1', '0' },       /* 'P' */                           
    { '1', '0', '0', '2', '2', '0' },       /* 'Q' */                           
                                                                                
    { '1', '2', '0', '0', '2', '0' },       /* 'R' */                           
    { '1', '0', '2', '0', '0', '2' },       /* 'S' */                           
    { '1', '0', '2', '2', '0', '0' },       /* 'T' */                           
    { '1', '0', '2', '0', '2', '0' },       /* 'U' */                           
    { '2', '0', '0', '0', '1', '2' },       /* 'V' */                           
    { '2', '0', '0', '2', '1', '0' },       /* 'W' */                           
    { '2', '2', '0', '0', '1', '0' },       /* 'X' */                           
    { '2', '0', '1', '0', '0', '2' },       /* 'Y' */                           
    { '2', '0', '1', '2', '0', '0' },       /* 'Z' */                           
    { '2', '2', '1', '0', '0', '0' },       /* '[' */                           
                                                                                
    { '2', '0', '3', '0', '0', '0' },       /* '\' */                           
    { '1', '1', '0', '3', '0', '0' },       /* ']' */                           
    { '3', '2', '0', '0', '0', '0' },       /* '^' */                           
    { '0', '0', '0', '1', '1', '3' },       /* '_' */                           
    { '0', '0', '0', '3', '1', '1' },       /* 'back-quote' */                  
    { '0', '1', '0', '0', '1', '3' },       /* 'a' */                           
    { '0', '1', '0', '3', '1', '0' },       /* 'b' */                           
    { '0', '3', '0', '0', '1', '1' },       /* 'c' */                           
    { '0', '3', '0', '1', '1', '0' },       /* 'd' */                           
    { '0', '0', '1', '1', '0', '3' },       /* 'e' */                           
                                                                                
    { '0', '0', '1', '3', '0', '1' },       /* 'f' */                           
    { '0', '1', '1', '0', '0', '3' },       /* 'g' */                           
    { '0', '1', '1', '3', '0', '0' },       /* 'h' */                           
    { '0', '3', '1', '0', '0', '1' },       /* 'i' */                           
    { '0', '3', '1', '1', '0', '0' },       /* 'j' */                           
    { '1', '3', '0', '1', '0', '0' },       /* 'k' */                           
    { '1', '1', '0', '0', '0', '3' },       /* 'l' */                           
    { '3', '0', '2', '0', '0', '0' },       /* 'm' */                           
    { '1', '3', '0', '0', '0', '1' },       /* 'n' */                           
    { '0', '2', '3', '0', '0', '0' },       /* 'o' */                           
                                                                                
    { '0', '0', '0', '1', '3', '1' },       /* 'p' */                           
    { '0', '1', '0', '0', '3', '1' },       /* 'q' */                           
    { '0', '1', '0', '1', '3', '0' },       /* 'r' */                           
    { '0', '0', '3', '1', '0', '1' },       /* 's' */                           
    { '0', '1', '3', '0', '0', '1' },       /* 't' */                           
    { '0', '1', '3', '1', '0', '0' },       /* 'u' */                           
    { '3', '0', '0', '1', '0', '1' },       /* 'v' */                           
    { '3', '1', '0', '0', '0', '1' },       /* 'w' */                           
    { '3', '1', '0', '1', '0', '0' },       /* 'x' */                           
    { '1', '0', '1', '0', '3', '0' },       /* 'y' */                           
                                                                                
    { '1', '0', '3', '0', '1', '0' },       /* 'z' */                           
    { '3', '0', '1', '0', '1', '0' },       /* '{' */                           
    { '0', '0', '0', '0', '3', '2' },       /* '|' */                           
    { '0', '0', '0', '2', '3', '0' },       /* '}' */                           
    { '0', '2', '0', '0', '3', '0' },       /* '~' */                           
    { '0', '0', '3', '0', '0', '2' },       /* 'DEL' */                         
    { '0', '0', '3', '2', '0', '0' },       /* 'FNC 3' */                       
    { '3', '0', '0', '0', '0', '2' },       /* 'FNC 2' */                       
    { '3', '0', '0', '2', '0', '0' },       /* 'SHIFT' */                       
    { '0', '0', '2', '0', '3', '0' },       /* 'CODE C' */                      
                                                                                
    { '0', '0', '3', '0', '2', '0' },       /* 'FNC 4' */                       
    { '2', '0', '0', '0', '3', '0' },       /* 'CODE A' */                      
    { '3', '0', '0', '0', '2', '0' },       /* 'FNC 1' */                       
    { '1', '0', '0', '3', '0', '1' },       /* 'START A' */                     
    { '1', '0', '0', '1', '0', '3' },       /* 'START B' */                     
    { '1', '0', '0', '1', '2', '1' } };     /* 'START C' */                     
                                                                                
/* Parameters passed to the main function */                                    
char            barcode;            /* type of bar code         */              
char            *input;             /* input string */                          
int             size;               /* size of input string */                  
unsigned char   *output;            /* output string    */                      
                                                                                
int             mlength[4];         /* size of users output  string        */   
char            binrepr[1024];      /* binary representation  */                
int             lenbinrepr;         /* size of binary representation      */    
                                                                                
/* Strings with valid digits for each type of bar code            */            
static char     val39chars[]    = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
static char     valdigits[]     = "0123456789";                                 
static char     c128lower[]     = "`abcdefghijklmnopqrstuvwxyz{|}]ˇ";           
                                                                                
static char     c128ctrl[]      = { '\x00', '\x01', '\x02', '\x03',             
                                    '\x04', '\x05', '\x06', '\x07',             
                                    '\x08', '\x09', '\x0A', '\x0B',             
                                    '\x0C', '\x0D', '\x0E', '\x0F',             
                                    '\x10', '\x11', '\x12', '\x13',             
        '\x14', '\x15', '\x16', '\x17',                                         
                                    '\x18', '\x19', '\x1A', '\x1B',             
                                    '\x1C', '\x1D', '\x1E', '\x1F' };           
                                                                                
static char     val128chrA[]    = { ' ', '!', '"', '#', '$', '%', '&', '\'',    
                                    '(', ')', '*', '+', ',', '-', '.', '/',     
                                    '0', '1', '2', '3', '4', '5', '6', '7',     
                                    '8', '9', ':', ';', '<', '=', '>', '?',     
                                    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G',     
                                    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',     
                                    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',     
        'X', 'Y', 'Z', '[', '\\', ']', '^', '_',                                
                                    '\x00', '\x01', '\x02', '\x03',             
                                    '\x04', '\x05', '\x06', '\x07',             
                                    '\x08', '\x09', '\x0A', '\x0B',             
                                    '\x0C', '\x0D', '\x0E', '\x0F',             
                                    '\x10', '\x11', '\x12', '\x13',             
                                    '\x14', '\x15', '\x16', '\x17',             
                                    '\x18', '\x19', '\x1A', '\x1B',             
                                    '\x1C', '\x1D', '\x1E', '\x1F',             
                                    '≥', '†', '?', '?', '?', 'ÿ', '≈' };        
                                                                                
static char     val128chrB[]    = { ' ', '!', '"', '#', '$', '%', '&', '\'',    
                                    '(', ')', '*', '+', ',', '-', '.', '/',     
                                    '0', '1', '2', '3', '4', '5', '6', '7',     
                                    '8', '9', ':', ';', '<', '=', '>', '?',     
                                    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G',     
                                    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',     
                                    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',     
                                    'X', 'Y', 'Z', '[', '\\', ']', '^', '_',    
                                    '`', 'a', 'b', 'c', 'd', 'e', 'f',          
                                    'g', 'h', 'i', 'j', 'k', 'l', 'm',          
                                    'n', 'o', 'p', 'q', 'r', 's', 't',          
                                    'u', 'v', 'w', 'x', 'y', 'z', '{',          
                                    '|', '}', '~', 'ˇ',                         
                                    '≥', '†', '?', '?', 'ÿ', '?', '≈' };        
                                                                                
static char     val128[]        = { ' ', 'Ÿ', '"', '¨', '$', '%', '&', '\'',    
                                    '(', ')', '*', '+', ',', '-', '.', '/',     
                                    '0', '1', '2', '3', '4', '5', '6', '7',     
                                    '8', '9', ':', ';', '<', '=', '>', '?',     
                                    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G',     
                                    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',     
                                    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',     
                                    'X', 'Y', 'Z', 'õ', '\\', '!', 'ç', '_',    
                                    '\x00', '\x01', '\x02', '\x03',             
                                    '\x04', '\x05', '\x06', '\x07',             
                                    '\x08', '\x09', '\x0A', '\x0B',             
                                    '\x0C', '\x0D', '\x0E', '\x0F',             
                                    '\x10', '\x11', '\x12', '\x13',             
                                    '\x14', '\x15', '\x16', '\x17',             
                                    '\x18', '\x19', '\x1A', '\x1B',             
                                    '\x1C', '\x1D', '\x1E', '\x1F',             
                                    '≥', '†', '?', '?', '?', 'ÿ', '≈',          
                                    '`', 'a', 'b', 'c', 'd', 'e', 'f',          
                                    'g', 'h', 'i', 'j', 'k', 'l', 'm',          
                                    'n', 'o', 'p', 'q', 'r', 's', 't',          
                                    'u', 'v', 'w', 'x', 'y', 'z', '{',          
                                    '|', '}', ']', 'ˇ', '#', '^', '[', '~'};                       
                                                                                
/* ASCII code points, used by the routine 'srconv' to convert the               
   code points to ASCII/EBCDIC                                                  
*/                                                                              
                                                                                
static char      tPuntosASCII[] = { '\x9D', '\x61', '\x62', '\x63', '\x64',     
         '\x65', '\x66', '\x67', '\x68', '\x69',                                
         '\xAE', '\xAF', '\xD0', '\xEC', '\xE7',                                
         '\xF1'};                                                               
static char      tPuntosEBCDIC[] = { '\x80', '\x81', '\x82', '\x83', '\x84',    
         '\x85', '\x86', '\x87', '\x88', '\x89',                                
         '\x8A', '\x8B', '\x8C', '\x8D', '\x8E',                                
         '\x8F'};                                                               
int             c128encode[C128MAXL];                                           
int             curr;                                                           
int             c128len;                                                        
int             state;                                                          
int             c128check;                                                      
                                                                                
/*-----------------------------------------------------------------------*/     
/* eansrc - Entry point for barcode generation                           */     
/*          See original PL/1 comments at top of file for details        */     
/*                                                                       */     
/* Input parameters                                                      */     
/* . _barcode - Bar encoding method                                      */     
/* . _input   - Input character string for encoding                      */     
/* . _size    - Size of input character string                           */     
/*                                                                       */     
/* Output parameters                                                     */     
/* . _output  - Encoded character string in ASCII character set          */     
/*   _size    - length of new character string (DPC MOD)                 */
/*                                                                       */
/* Return value - Size of input character string                         */     
/*                                                                       */     
/*-----------------------------------------------------------------------*/     

/* DPC MOD - added * to _barcode and _size, added short to next line */
int eansrc( char *_barcode, const char *_input, short int *_size, char *_output)
{                                                                               
                                                                                
    barcode = *_barcode;    /* DPC MOD - added * */
    input   = (char *) _input;                                                  
    size    = *_size;       /* DPC MOD - added * */
    output  = (unsigned char *) _output;                                        

    /* Initialize the global variables */                                       
    initialize();                                                               
                                                                                
    /* Process the input data to determine the bar code type */                 
    switch ( toupper( barcode ) )                                               
    {                                                                           
        case 'E':   eancl( UENARR );                                            
                    break;                                                      
        case 'I':   itf( NARROW, ITFNN, ITFNW );                                
                    break;                                                      
        case 'A':   indcl( INDUST, INDN, INDW );                                
                    break;                                                      
        case 'B':   itf( WIDE, ITFWN, ITFWW );                                  
                    break;                                                      
        case 'C':   code128( C128NARR );                                        
                    break;                                                      
        case '3':   cod39( NARROW, C39NN, C39NW );                              
                    break;                                                      
        case '6':   cod39( WIDE, C39WN, C39WW );                                
                    break;                                                      
        case 'M':   codmsi( MSIN, MSIW );                                       
                    break;                                                      
        case 'T':   indcl( MATRIX, MATN, MATW );                                
                    break;                                                      
        case 'U':   upc( UPCA, UENARR );                                        
                    break;                                                      
        case 'V':   upc( UPCE, UENARR );                                        
                    break;                                                      
        case 'W':   upcenum1( UENARR );                                         
                    break;                                                      
        default:    errmsg( 1, ' ' );                                           
                    break;                                                      
    }                                                                           

    *_size    =  size;     /* DPC MOD - added line */
    return ( size );                                                            
}                                                                               
                                                                                
                                                                                
/*-----------------------------------------------------------------------*/     
/*              initialize - Initialize the Global Variables             */     
/*-----------------------------------------------------------------------*/     
                                                                                
/* Initialize the global variables */                                           
static void initialize( void )                                                  
{                                                                               
    /* Initialize output to the blank bar code character (hex '80') */          
                                                                                
#ifdef __FOXPRO__                                                               
    _MemFill( (char *) output, BLANK_CHAR, MAX_OUT );                           
#else                                                                           
    memset( (char *) output, BLANK_CHAR, MAX_OUT );                             
#endif                                                                          
                                                                                
    /* Initialize binrepr to null string */                                     
                                                                                
    lenbinrepr = 0;                                                             
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                                                                       */     
/*                          EAN AND UPC ROUTINES                         */     
/*                                                                       */     
/*-----------------------------------------------------------------------*/     
                                                                                
/*-----------------------------------------------------------------------*/     
/*                      eancl - Process EAN 8 and 13                     */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void eancl( int narrsize )                                               
{                                                                               
    /* Verify length of input string is 7,8,12, or 13 */                        
    if ( size != 7 && size != 8 && size != 12 && size != 13 )                   
    {                                                                           
        errmsg( 10, ' ' );                                                      
        return;                                                                 
    }                                                                           
                                                                                
    /* Validate input data by calling validate, return if error */              
    if ( !validate( valdigits, DEFAULTCODE ) )  /* 'valdigits' es NULL-ended */ 
        return;                                                                 
                                                                                
    /* If length is 7 or 12 then add a check digit */                           
    if ( size == 7 || size == 12 )                                              
        checksr( 3 );                                                           
                                                                                
    /* Set mlength(n) to values for bar sizes */                                
    mlength[0] = narrsize;                                                      
    mlength[1] = narrsize * 2;                                                  
    mlength[2] = narrsize * 3;                                                  
    mlength[3] = narrsize * 4;                                                  
                                                                                
    /* Generate correct binary representation of EAN 8 or EAN 13 */             
    if ( size == 8 )                                                            
        sre8ua( 4 );                                                            
    else                                                                        
        srean13();                                                              
                                                                                
    /* Convert binary representation to code points for output */               
    srconv();                                                                   
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                       upc - Process UPC A and E                       */     
/*-----------------------------------------------------------------------*/     
                                                                                
/* Procesa codificaciones UPC A y UPC E */                                      
static void upc( int upctype, int narrsize )                                    
{                                                                               
    char data[6];                                                               
                                                                                
    /* Verify length of input string is 11 */                                   
    if ( size != 11 )                                                           
    {                                                                           
        errmsg( 11, ' ' );                                                      
        return;                                                                 
    }                                                                           
                                                                                
    /* Validate input data by calling validate, return if error */              
    if ( !validate( valdigits, DEFAULTCODE ) )  /* 'valdigits' es NULL-ended */ 
        return;                                                                 
                                                                                
    /* Add a check digit */                                                     
    checksr( 3 );                                                               
                                                                                
    /* Set mlength(n) to values for bar sizes */                                
    mlength[0] = narrsize;                                                      
    mlength[1] = narrsize * 2;                                                  
    mlength[2] = narrsize * 3;                                                  
    mlength[3] = narrsize * 4;                                                  
                                                                                
    /* Generate correct binary representation of upc a or upc e */              
    if ( upctype == UPCE )                                                      
    {                                                                           
 if ( zerosupp( data )!= -1 )                                                   
            return;                                                             
                                                                                
 srupce( data, NUM_SYS_0 );                      /* @001 */                     
    }                                                                           
    else                                                                        
        /* Else if encoding UPC A call sre8ua for processing */                 
        sre8ua( 6 );                                                            
                                                                                
    /* Convert binary representation to code points for output */               
    srconv();                                                                   
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*     UPC E Number System 1 - Special bar code type for shelf labels    */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void upcenum1( int narrsize )        /* New routine @001 */              
{                                                                               
    char data[6];                                                               
                                                                                
    /* Verify length of input string is 6 */                                    
    if ( size != 6 )                                                            
    {                                                                           
        errmsg( 15, ' ' );                                                      
        return;                                                                 
    }                                                                           
                                                                                
    /* Copy the input data into a different buffer and save its value */        
                                                                                
#ifdef __FOXPRO__                                                               
    _MemMove( (char *) data, (char *) input, size );                            
#else                                                                           
    memcpy( (char *) data, (char *) input, size );                              
#endif                                                                          
                                                                                
    /* Validate input data by calling validate, return if error */              
    if ( !validate( valdigits, DEFAULTCODE ) )                                  
        return;                                                                 
                                                                                
    /* Create the 11 digit UPC number from the 6 input digits */                
    x6to11( data );                                                             
                                                                                
    /* Add a check digit */                                                     
    checksr( 3 );                                                               
                                                                                
    /* Set mlength(n) to values for bar sizes */                                
    mlength[0] = narrsize;                                                      
    mlength[1] = narrsize * 2;                                                  
    mlength[2] = narrsize * 3;                                                  
    mlength[3] = narrsize * 4;                                                  
                                                                                
    /* Generate correct binary representation of UPC A or UPC E */              
    srupce( data, NUM_SYS_1 );                                                  
                                                                                
    srconv();                                                                   
                                                                                
    size = 6;                                                                   
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*            srean13 - Generates EAN 13 Binary Representation           */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void srean13( void )                                                     
{                                                                               
    char    *parity;                                                            
    char    *encoding;                                                          
    int     charnum;                                                            
    int     digit;                                                              
    int     nmbset;                                                             
    int     f1;                                                                 
                                                                                
    /* Add start guard to binary representation */                              
    genbin( "000", 3, 0 );                                                      
                                                                                
    /* Get flag digit 'f1' from input string (left most digit) */               
    f1 = CTOI( input[0] );                                                      
                                                                                
    /* Get parity pattern from array which 'f1' represents */                   
    parity = &parity13[f1][0];                                                  
                                                                                
    /* Encode the left six digits using the parity pattern */                   
    for ( charnum = 0; charnum < 6; charnum++ )                                 
    {                                                                           
        /* Get next digit to encode */                                          
 digit = CTOI( input[charnum + 1] );                                            
                                                                                
        /* Get number set to encode digit with from parity pattern */           
 nmbset = CTOI( parity[charnum] );                                              
                                                                                
        /* Get binary representation using number set and digit */              
 encoding = &numsets[nmbset][digit][0];                                         
                                                                                
        /* Generate binary representation of the encoding */                    
        genbin( encoding, 4, 1 );                                               
    }                                                                           
                                                                                
    genbin( "00000", 5, 1 );                                                    
                                                                                
    /* Set number set to encode digit with to EAN C (UPC right) */              
    nmbset = 2;                                                                 
                                                                                
    /* Encode the right six digits using number set EAN C (UPC right) */        
    for ( charnum = 0; charnum < 6; charnum++ )                                 
    {                                                                           
        /* Get next digit to encode */                                          
 digit = CTOI( input[charnum + 7] );                                            
                                                                                
 /* Get binary representation using number set and digit */                     
 encoding = &numsets[nmbset][digit][0];                                         
                                                                                
        /* Generate binary representation of the encoding */                    
        genbin( encoding, 4, 0 );                                               
    }                                                                           
    /* Add stop guard to binary representation */                               
    genbin( "000", 3, 0 );                                                      
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*        sre8ua - Generates EAN 8 and UPC A Binary Representation       */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void sre8ua( int numhalf )                                               
{                                                                               
    char    *encoding;                                                          
    int     nmbset;                                                             
    int     charnum;                                                            
    int     digit;                                                              
                                                                                
    /* Add start guard to binary representation */                              
    genbin( "000", 3, 0 );                                                      
                                                                                
    /* Set number set to encode with to EAN A (UPC left odd) */                 
    nmbset = 0;                                                                 
                                                                                
    /* Encode left numhalf digits using number set EAN A (left odd) */          
    for ( charnum = 0; charnum < numhalf; charnum++ )                           
    {                                                                           
        /* Get next digit to encode */                                          
 digit = CTOI( input[charnum] );                                                
                                                                                
 /* Get binary representation using number set and digit */                     
 encoding = &numsets[nmbset][digit][0];                                         
                                                                                
 /* Generate binary representation of the encoding */                           
 genbin( encoding, 4, 1 );                                                      
    }                                                                           
                                                                                
    genbin( "00000", 5, 1 );                                                    
                                                                                
    /* Set number set to encode digit with to EAN C (UPC right) */              
    nmbset = 2;                                                                 
                                                                                
    /* Encode right numhalf digits using number set EAN C (UPC right) */        
    for ( charnum = 0; charnum < numhalf; charnum++ )                           
    {                                                                           
        /* Get next digit to encode */                                          
 digit = CTOI( input[charnum + numhalf] );                                      
                                                                                
        /* Get binary representation using number set and digit */              
 encoding = &numsets[nmbset][digit][0];                                         
                                                                                
        /* Generate binary representation of the encoding */                    
        genbin( encoding, 4, 0 );                                               
    }                                                                           
    /* Add stop guard to binary representation */                               
    genbin( "000", 3, 0 );                                                      
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                                                                       */     
/*                             UPC E ROUTINES                            */     
/*                                                                       */     
/*-----------------------------------------------------------------------*/     
                                                                                
/*-----------------------------------------------------------------------*/     
/*             srupce - Generates UPC E Binary Representation            */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void srupce( char *data, int num_system )        /* @001 */              
{                                                                               
    char    *parity;                                                            
    char    *encoding;                                                          
    int     digit;                                                              
    int     nmbset;                                                             
    int     charnum;                                                            
    int     chk;                                                                
                                                                                
    /* Get check digit from input string (right most digit) */                  
    chk = CTOI( input[11] );        /* convedr•a usar size - 1 como •ndice */   
                                                                                
    /* Get parity pattern which chk represents from parity array */             
    parity = &parityE[num_system][chk][0];              /* @001 */              
                                                                                
    /* Add start guard to binary representation */                              
    genbin( "000", 3, 0 );                                                      
                                                                                
    /* Encode the left six digits using the parity pattern */                   
    for ( charnum = 0; charnum < 6; charnum++ )                                 
    {                                                                           
 /* Get next digit to encode */                                                 
 digit = CTOI( data[charnum] );                                                 
                                                                                
        /* Get number set to encode digit with from parity pattern */           
 nmbset = CTOI( parity[charnum] );                                              
                                                                                
 /* Get binary representation using number set and digit */                     
 encoding = &numsets[nmbset][digit][0];                                         
                                                                                
        /* Generate binary representation of the encoding */                    
        genbin( encoding, 4, 1 );                                               
    }                                                                           
    genbin( "000000", 6, 1 );                                                   
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*       zerosupp - Determine the Zero Suppression Digits to Encode      */     
/*-----------------------------------------------------------------------*/     
                                                                                
static int zerosupp( char *data )                                               
{                                                                               
    int rcode;                                                                  
                                                                                
    /* If manufacturer number does not end in zero then */                      
    if ( input[5] != '0' )                                                      
    {                                                                           
        /* Get six characters to encode (2,3,4,5,6,11) */                       
                                                                                
#ifdef __FOXPRO__                                                               
        _MemMove( (char *) data, (char *) input + 1, 5 );                       
#else                                                                           
 memcpy( (char *) data, (char *) input + 1, 5 );                                
#endif                                                                          
                                                                                
 data[5] = input[10];                                                           
                                                                                
 /* Verify digits 7 through 10 are zero */                                      
 rcode = verify( (char *) input + 6, 4, "0", 1 );                               
                                                                                
        /* If no error yet then verify digit 11 is one of 5,6,7,8,9 */          
        if ( rcode == -1 )                                                      
            rcode = verify( (char *) input + 10, 1, "56789", 5 );               
    }                                                                           
    /* Else if number ends in 10,20,30,40,50,60,70,80,90 then */                
    else                                                                        
    {                                                                           
 if ( input[4] != '0' )                                                         
 {                                                                              
     /* Get six characters to encode (2,3,4,5,11,'4') */                        
#ifdef __FOXPRO__                                                               
     _MemMove( (char *) data, (char *) input + 1, 4 );                          
#else                                                                           
     memcpy( (char *) data, (char *) input + 1, 4 );                            
#endif                                                                          
     data[4] = input[10];                                                       
     data[5] = '4';                                                             
                                                                                
     /* Verify digits 6 through 10 are zero */                                  
            rcode = verify( (char *) input + 5, 5, "0", 1 );                    
        }                                                                       
        /* Else if number ends in 300,400,500,600,700,800,900 then */           
        else                                                                    
        {                                                                       
     if ( input[3] > '2' )                                                      
            {                                                                   
                /* Get six characters to encode (2,3,4,10,11,'3') */            
#ifdef __FOXPRO__                                                               
  _MemMove( (char *) data, (char *) input + 1, 3 );                             
  _MemMove( (char *) data + 3, (char *) input + 9, 2 );                         
#else                                                                           
  memcpy( (char *) data, (char *) input + 1, 3 );                               
  memcpy( (char *) data + 3, (char *) input + 9, 2 );                           
#endif                                                                          
  data[5] = '3';                                                                
                                                                                
                /* Verify digits 5 through 9 are zero */                        
                rcode = verify( (char *) input + 4, 5, "0", 1 );                
            }                                                                   
            /* Else number ends in 000, 100 or 200 then */                      
            else                                                                
            {                                                                   
  /* Get six characters to encode (2,3,9,10,11,4) */                            
#ifdef __FOXPRO__                                                               
  _MemMove( (char *) data, (char *) input + 1, 2 );                             
  _MemMove( (char *) data + 2, (char *) input + 8, 3 );                         
#else                                                                           
  memcpy( (char *) data, (char *) input + 1, 2 );                               
  memcpy( (char *) data + 2, (char *) input + 8, 3 );                           
#endif                                                                          
  data[5] = input[3];                                                           
                                                                                
                /* Verify digits 5 through 8 are zero */                        
                rcode = verify( (char *) input + 4, 4, "0", 1 );                
            }                                                                   
        }                                                                       
    }                                                                           
                                                                                
    /* If no error yet then verify digit 1 is zero or one */                    
    if ( rcode != -1 || ( rcode = ( input[0] == '0' ? -1 : 0 ) ) != -1 )        
 errmsg( 12, ' ' );                                                             
                                                                                
    return ( rcode );                                                           
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*       x6to11 - Convert the 6 digit input number to 11 digit UPC       */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void x6to11( char *in6 )             /* New routine @001 */              
{                                                                               
    char out10[10];                                                             
    char f;                                                                     
                                                                                
    /* The input format is 'ABCDEF'                                */           
    /* Get the 'F' digit of the 6 digit number to use for decoding */           
    f = in6[5];                                                                 
                                                                                
    /* If 'f' is a 0,1, or 2 then */                                            
    if ( f == '0' || f == '2' || f == '2' )                                     
    {                                                                           
        /* The 10 digit format is 'ABF0000CDE' */                               
                                                                                
#ifdef __FOXPRO__                                                               
 _MemMove( (char *) out10, (char *) in6, 2 );                                   
#else                                                                           
 memcpy( (char *) out10, (char *) in6, 2 );                                     
#endif                                                                          
                                                                                
 out10[2] = in6[5];                                                             
                                                                                
#ifdef __FOXPRO__                                                               
 _MemFill( (char *) out10 + 3, '0', 4 );                                        
 _MemMove( (char *) out10 + 7, (char *) in6 + 2, 3 );                           
#else                                                                           
 memset( (char *) out10 + 3, '0', 4 );                                          
 memcpy( (char *) out10 + 7, (char *) in6 + 2, 3 );                             
#endif                                                                          
                                                                                
    }                                                                           
    else                                                                        
    {                                                                           
        /* If 'F' is 3 then */                                                  
        if ( f == '3' )                                                         
        {                                                                       
            /* The 10 digit format is 'ABC00000DE' */                           
                                                                                
#ifdef __FOXPRO__                                                               
     _MemMove( (char *) out10, (char *) in6, 3 );                               
     _MemFill( (char *) out10 + 3, '0', 5 );                                    
     _MemMove( (char *) out10 + 8, (char *) in6 + 3, 2 );                       
#else                                                                           
     memcpy( (char *) out10, (char *) in6, 3 );                                 
     memset( (char *) out10 + 3, '0', 5 );                                      
     memcpy( (char *) out10 + 8, (char *) in6 + 3, 2 );                         
#endif                                                                          
                                                                                
        }                                                                       
        else                                                                    
        {                                                                       
            /* If 'F' is 4 then */                                              
            if ( f == '4' )                                                     
            {                                                                   
                /* The 10 digit format is 'ABCD00000E' */                       
                                                                                
#ifdef __FOXPRO__                                                               
                _MemMove( (char *) out10, (char *) in6, 4 );                    
                _MemFill( (char *) out10 + 4, '0', 5 );                         
#else                                                                           
  memcpy( (char *) out10, (char *) in6, 4 );                                    
  memset( (char *) out10 + 4, '0', 5 );                                         
#endif                                                                          
                                                                                
  out10[9] = in6[4];                                                            
     }                                                                          
     else                                                                       
     {                                                                          
                /* If 'F' is 5,6,7,8 or 9 then */                               
                if ( f >= '5' && f <= '9' )                                     
                {                                                               
                    /* The 10 digit format is 'ABCDE0000F' */                   
                                                                                
#ifdef __FOXPRO__                                                               
      _MemMove( (char *) out10, (char *) in6, 5 );                              
      _MemFill( (char *) out10 + 5, '0', 4 );                                   
#else                                                                           
                    memcpy( (char *) out10, (char *) in6, 5 );                  
                    memset( (char *) out10 + 5, '0', 4 );                       
#endif                                                                          
                                                                                
      out10[9] = in6[5];                                                        
  }                                                                             
     }                                                                          
 }                                                                              
    }                                                                           
                                                                                
    /* Set the number system digit to '1' */                                    
    input[0] = '1';                                                             
                                                                                
#ifdef __FOXPRO__                                                               
    _MemMove( (char *) input + 1, (char *) out10, 10 );                         
#else                                                                           
    memcpy( (char *) input + 1, (char *) out10, 10 );                           
#endif                                                                          
                                                                                
    /* Set the size of the data to 11 */                                        
    size = 11;                                                                  
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                                                                       */     
/*            INTERLEAVED, INDUSTRIAL, MATRIX 2 OF 5 ROUTINES            */     
/*                                                                       */     
/*-----------------------------------------------------------------------*/     
                                                                                
/*-----------------------------------------------------------------------*/     
/*      convert - Converts two patterns to one interleaved encoding      */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void convert( char *strbars, char *strspcs, char *dest )                 
{                                                                               
    int cnt;                                                                    
                                                                                
    for ( cnt = 0; cnt < 5; cnt++ )                                             
    {                                                                           
        /* Combine wrk with current character of strbars then strspcs */        
 dest[2 * cnt]       = strbars[cnt];                                            
 dest[2 * cnt + 1]   = strspcs[cnt];                                            
    }                                                                           
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                    itf - Process Interleaved 2 of 5                   */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void itf( int varsize, int narrsize, int widesize )                      
{                                                                               
    if ( varsize == NARROW )                                                    
    {                                                                           
        if ( size > 80 )                                                        
        {                                                                       
            errmsg( 7, ' ' );                                                   
            return;                                                             
        }                                                                       
    }                                                                           
    else                                                                        
    {                                                                           
        if ( varsize == WIDE )                                                  
        {                                                                       
            if ( size > 40 )                                                    
            {                                                                   
                errmsg( 8, ' ' );                                               
                return;                                                         
            }                                                                   
        }                                                                       
    }                                                                           
                                                                                
    /* Validate input data by calling validate, return if error */              
    if ( !validate( valdigits, DEFAULTCODE ) )                                  
        return;                                                                 
                                                                                
    /* Set mlength(1) and mlength(0) to values for sizes */                     
    mlength[0] = narrsize;                                                      
    mlength[1] = widesize;                                                      
                                                                                
    /* Add a check digit if length is odd */                                    
    if ( size % 2 == 1 )                                                        
        checksr( 3 );                                                           
                                                                                
    /* Generate the binary representation of Interleaved 2 of 5 */              
    sritf();                                                                    
                                                                                
    /* Convert binary representation to code points for output */               
    srconv();                                                                   
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*       sritf - Generates Interleaved 2 of 5 Binary Representation      */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void sritf( void )                                                       
{                                                                               
    int     itf1;                                                               
    int     itf2;                                                               
    int     charnum;                                                            
    char    encoding[10];                                                       
                                                                                
    /* Add start guard to binary representation */                              
    genbin( "0000", 4,  0 );                                                    
                                                                                
    for ( charnum = 0; charnum < size - 1; charnum += 2 )                       
    {                                                                           
        /* Get left  digit */                                                   
 itf1 = CTOI( input[charnum] );                                                 
                                                                                
 /* Get right digit */                                                          
 itf2 = CTOI( input[charnum + 1] );                                             
                                                                                
        /* Convert the two encodings to interleaved encoding */                 
 convert( &br25[itf1][0], &br25[itf2][0], encoding );                           
                                                                                
 /* Generate binary representation of the encoding */                           
 genbin( encoding, sizeof( encoding ), 0 );                                     
    }                                                                           
                                                                                
    /* Add stop guard to binary representation */                               
    genbin( "100", 3, 0 );                                                      
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*              indcl - Process Industrial and Matrix 2 of 5             */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void indcl( int btype, int narrsize, int widesize )                      
{                                                                               
    /* Verify length of input string is less than or equal to 35 */             
    if ( size > 35 )                                                            
    {                                                                           
        errmsg( 9, ' ' );                                                       
        return;                                                                 
    }                                                                           
                                                                                
    /* Validate input data by calling validate, return if error */              
    if ( !validate( valdigits, DEFAULTCODE ) )                                  
 return;                                                                        
                                                                                
    /* Set mlength(1) and mlength(0) to values for sizes */                     
    mlength[0] = narrsize;                                                      
    mlength[1] = widesize;                                                      
                                                                                
    /* Generate binary representation for industrial or matrix 2 of 5 */        
    srind( btype );                                                             
                                                                                
    /* Convert binary representation to code points for output */               
    srconv();                                                                   
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*    srind - Generates Industrial/Matrix 2 of 5 Binary Representation   */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void srind( int btype )                                                  
{                                                                               
    char    *mend;                                                              
    int     charnum;                                                            
    int     itf1;                                                               
    char    encoding[10];                                                       
    int     encodlen;                                                           
                                                                                
    /* If constructing Industrial 2 of 5 then */                                
    if ( btype == INDUST )                                                      
    {                                                                           
        /* Construct stop guard */                                              
                                                                                
#ifdef __FOXPRO__                                                               
    _StrCpy ( (char *) mend, "10001" );                                         
#else                                                                           
    strcpy ( (char *) mend, "10001" );                                          
#endif                                                                          
                                                                                
        /* Add start guard to binary representation */                          
        genbin( "101000", 6, 0 );                                               
                                                                                
        encodlen = 10;                                                          
    }                                                                           
    /* Else if constructing Matrix 2 of 5 then */                               
    else                                                                        
    {                                                                           
        /* Construct stop guard */                                              
                                                                                
#ifdef __FOXPRO__                                                               
    _StrCpy ( (char *) mend, "10000" );                                         
#else                                                                           
    strcpy ( (char *) mend, "10000" );                                          
#endif                                                                          
                                                                                
        /* Add start guard to binary representation */                          
        genbin( "100000", 6, 0 );                                               
                                                                                
        encodlen = 6;                                                           
    }                                                                           
                                                                                
    /* For each digit in the input string do */                                 
    for ( charnum = 0; charnum < size; charnum++ )                              
    {                                                                           
        /* Get the digit to encode */                                           
 itf1 = CTOI( input[charnum] );                                                 
                                                                                
 /* If Industrial 2 of 5 then */                                                
 if ( btype == INDUST )                                                         
 {                                                                              
     /* Convert encoding to Industrial */                                       
     convert( &br25[itf1][0], "00000", encoding );                              
        }                                                                       
        else                                                                    
        {                                                                       
            /* Add a trailing space for Matrix 2 of 5 */                        
                                                                                
#ifdef __FOXPRO__                                                               
     _MemMove( (char *) encoding, (char *) &br25[itf1][0], 5 );                 
#else                                                                           
     memcpy( (char *) encoding, (char *) &br25[itf1][0], 5 );                   
#endif                                                                          
                                                                                
     encoding[5] = '0';                                                         
        }                                                                       
        /* Generate binary representation of the encoding */                    
        genbin( encoding, encodlen, 0 );                                        
    }                                                                           
    /* Add stop guard to binary representation */                               
    genbin( mend, 5, 0 );                                                       
}                                                                               
                                                                                
/* ===================================================================== */     
/*                                                                       */     
/*                              MSI ROUTINES                             */     
/*                                                                       */     
/* ===================================================================== */     
                                                                                
/*-----------------------------------------------------------------------*/     
/*                          codmsi - Process MSI                         */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void codmsi( int narrsize, int widesize )                                
{                                                                               
    /* Verify length of input string is less than or equal to 15 */             
    if ( size > 15 )                                                            
    {                                                                           
        errmsg( 4, ' ' );                                                       
        return;                                                                 
    }                                                                           
    /* Validate input data by calling validate, return if error */              
    if ( !validate( valdigits, DEFAULTCODE ) )                                  
        return;                                                                 
                                                                                
    /* Set mlength(1) and mlength(0) to values for sizes */                     
    mlength[0] = narrsize;                                                      
    mlength[1] = widesize;                                                      
                                                                                
    /* Generate binary representation for MSI */                                
    srmsi();                                                                    
                                                                                
    /* Convert binary representation to code points for output */               
    srconv();                                                                   
}                                                                               
                                                                                
                                                                                
/*-----------------------------------------------------------------------*/     
/*              srmsi - Generates MSI Binary Representation              */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void srmsi( void )                                                       
{                                                                               
    int     charnum;                                                            
    int     num;                                                                
    char    *encoding;                                                          
                                                                                
    /* Add start guard to binary representation */                              
    genbin( "10", 2, 0 );                                                       
                                                                                
    for ( charnum = 0; charnum < size; charnum++ )                              
    {                                                                           
        /* Get the digit from input */                                          
 num = CTOI( input[charnum] );                                                  
                                                                                
 /* Get module encoding of this digit */                                        
 encoding = &msibr[num][0];                                                     
                                                                                
        /* Generate binary representation of the encoding */                    
        genbin( encoding, 8, 0 );                                               
    }                                                                           
    /* Add stop guard to binary representation */                               
    genbin( "010", 3, 0 );                                                      
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                                                                       */     
/*                            CODE 39 ROUTINES                           */     
/*                                                                       */     
/*-----------------------------------------------------------------------*/     
                                                                                
/*-----------------------------------------------------------------------*/     
/*                        cod39 - Process Code 39                        */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void cod39( int varsize, int narrsize, int widesize )                    
{                                                                               
    /* If producing narrow bars then */                                         
    if ( varsize == NARROW )                                                    
    {                                                                           
        /* Verify length of input string is less than or equal to 30 */         
        if ( size > 30 )                                                        
        {                                                                       
            errmsg( 5, ' ' );                                                   
     return;                                                                    
        }                                                                       
    }                                                                           
    else                                                                        
    {                                                                           
        /* Else if producing wide bars then */                                  
        if ( varsize == WIDE )                                                  
        {                                                                       
     /* Verify length of input string is less than or equal to 14 */            
            if ( size > 14 )                                                    
            {                                                                   
                errmsg( 6, ' ' );                                               
                return;                                                         
            }                                                                   
        }                                                                       
    }                                                                           
    /* Validate input data by calling validate, return if error */              
    if ( !validate( val39chars, FCODE39 ) )                                     
 return;                                                                        
                                                                                
    /* Set mlength(1) and mlength(0) to values for sizes */                     
    mlength[0] = narrsize;                                                      
    mlength[1] = widesize;                                                      
                                                                                
    /* Generate binary representation of 3 of 9 code */                         
    srcod39();                                                                  
                                                                                
    /* Convert binary representation to code points for output */               
    srconv();                                                                   
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*            srcod39 - Generate Code 39 Binary Representation           */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void srcod39( void )                                                     
{                                                                               
    int     charnum;                                                            
    int     ipos;                                                               
    char    *encoding;                                                          
                                                                                
    genbin( "0100101000", 10, 0 );                                              
                                                                                
    for ( charnum = 0; charnum < size; charnum++ )                              
    {                                                                           
 /* Get the digit to encode */                                                  
 ipos = ch_index( val39chars, input[charnum], sizeof( val39chars ) - 1 );       
                                                                                
 encoding = &c39br[ipos][0];                                                    
                                                                                
        /* Generate binary representation of the encoding */                    
        genbin( encoding, 9, 0 );                                               
                                                                                
        /* Add intercharacter gap into binary representation */                 
                                                                                
#ifdef __FOXPRO__                                                               
 _MemFill( (char *) binrepr + lenbinrepr, '0', mlength[0] );                    
#else                                                                           
 memset( (char *) binrepr + lenbinrepr, '0', mlength[0] );                      
#endif                                                                          
                                                                                
 lenbinrepr += mlength[0];                                                      
    }                                                                           
    /* Add stop guard to binary representation */                               
    genbin( "010010100", 9, 0 );                                                
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                                                                       */     
/*                           CODE 128 ROUTINES                           */     
/*                                                                       */     
/*-----------------------------------------------------------------------*/     
                                                                                
/*-----------------------------------------------------------------------*/     
/*                       code128 - Process Code 128                      */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void code128( int narrsize )                                             
{         
	int i,j;
	char CSOencode[256];
    /* Verify length of input string is less than or equal to 28 */             
    /* printf("size is %d\n", size); */
    /* printf("input is %s\n", input); */
    if ( size > 50 )                                                            
    {                                                                           
        errmsg( 14, ' ' );                                                      
        return;                                                                 
    }                                                                           
                                                                                
    /* Validate input data by calling validate, return if error */              
    if ( !validate( val128, FCODE128 ) )                                        
 return;                                                                        
                                                                                
    /* Set mlength(1) and mlength(0) to values for sizes */                     
    mlength[0] = narrsize;                                                      
    mlength[1] = narrsize * 2;                                                  
    mlength[2] = narrsize * 3;                                                  
    mlength[3] = narrsize * 4;                                                  
                                                                                
    /* Transform the input according to appendix G in AIM spec */               
    appg();                                                                     
/*
//	Leave AIM encoding intact and pass it back
	for ( i = 0; i < c128len; i++ )
	{
		output[i] = c128encode[i];
	}
*/
/*
	CSO doesn't use the IBM binary representation
	The encoded value must be changed to allow usage of the code page
	provided by the barcode font currently in use by CSO.  The barcode
	in use on the InfoPrint Manager for NT system at CSO was converted
	from an Elfring Bar Code 128 Subset C TrueType font and it uses the
	same code page provided by Elfring.
*/

//	New stuff added by CSO

//	Setup the CSO code page
	memset ( CSOencode, 0xff, 256 );
	for ( i = 0; i < 90; i++ )
	{
		CSOencode[i] = i + 33;
	}
	for ( i = 90; i < 100; i++ )
	{
		CSOencode[i] = i + 71;
	}
	for ( i = 100; i < 103; i++ )
	{
		CSOencode[i] = i + 76;
	}
	for ( i = 103; i < 107; i++ )
	{
		CSOencode[i] = i + 20;
	}

//	Perform the final code page conversion
	for ( i = 0; i < c128len; i++ )
	{
		j = c128encode[i];
		output[i] = CSOencode[j];
	}
	size = c128len;

//	End of CSO stuff

//	Old IBM stuff no longer used

    /* Generate the binary representation of Code 128 */                        
//    srcod128();                                                                 
                                                                                
    /* Convert binary representation to code points for output */               
//    srconv();                                                                   
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*           srcod128 - Generate Code 128 Binary Representation          */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void srcod128( void )                                                    
{                                                                               
    char    *encoding;                                                          
    int     charnum;                                                            
                                                                                
    /* For each digit in the input string do */                                 
    for ( charnum = 0; charnum < c128len; charnum++ )                           
    {                                                                           
        /* Get the digit to encode */                                           
 encoding = &c128br[c128encode[charnum]][0];                                    
                                                                                
        /* Generate binary representation of the encoding */                    
        genbin( encoding, 6, 0 );                                               
    }                                                                           
                                                                                
    /* Add stop guard to binary representation */                               
    genbin( "1220001", 7, 0 );                                                  
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*         appg - Implements Appendix G In AIM Spec for Code 128         */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void appg( void )                                                        
{                                                                               
    curr    = 0;                                                                
    c128len = 0;                                                                
                                                                                
    /* How many digits are at current position */                               
    /* If more than 4 digits then change to Code C */                           
    if ( numdigits() >= 4 )                                                     
    {                                                                           
        /* Start in Code C */                                                   
        insert( ZSTARTC );                                                      
        state = CSTATE;                                                         
    }                                                                           
    else                                                                        
    {                                                                           
        /* Is current charcter a Hex 8F */                                      
 if ( input[curr] == '\x8F' )                                                   
        {                                                                       
            insert( ZSTARTC );                                                  
            state = CSTATE;                                                     
            prochar( val128chrB, sizeof( val128chrB ) );                        
        }                                                                       
        else                                                                    
        {                                                                       
            /* Is current character a control character */                      
            if ( nextsp( curr, size ) == KCONTROL )                             
     {                                                                          
                /* Start in Code A */                                           
                insert( ZSTARTA );                                              
                state = ASTATE;                                                 
            }                                                                   
            else                                                                
            {                                                                   
                /* Start in Code B */                                           
                insert( ZSTARTB );                                              
  state = BSTATE;                                                               
            }                                                                   
        }                                                                       
    }                                                                           
                                                                                
    /* For each digit in the input string do */                                 
    while ( curr < size )                                                       
    {                                                                           
        /* Process the character in the correct code */                         
 switch ( state )                                                               
        {                                                                       
            case ASTATE:    codea();                                            
                            break;                                              
            case BSTATE:    codeb();                                            
                            break;                                              
            case CSTATE:    codec();                                            
            default:        break;                                              
        }                                                                       
    }                                                                           
    /* Insert the check digit */                                                
    insert( c128check );    
	/*	CSO needs a stop byte */
	insert( ZSTOP );
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                codea - Process character when in Code A               */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void codea( void )                                                       
{                                                                               
    /* How many digits are at current position */                               
    int numd = numdigits();                                                     
                                                                                
    /* If more than 4 digits then change to Code C */                           
    if ( numd >= 4 && numd % 2 == 0 )                                           
    {                                                                           
        insert( ZCODEC );                                                       
        state = CSTATE;                                                         
    }                                                                           
    else                                                                        
    {                                                                           
        /* Is current character a lower case character */                       
        if ( nextsp( curr, curr ) == KLOWER )                                   
        {                                                                       
            /* If next special is a control character */                        
            if ( nextsp( curr + 1, size ) == KCONTROL )                         
            {                                                                   
                /* Shift for the one lower case letter */                       
  insert( ZSHIFT );                                                             
                prochar( val128chrB, sizeof( val128chrB ) );                    
            }                                                                   
            else                                                                
            {                                                                   
                /* If next special is also a lower case letter */               
                                                                                
                insert( ZCODEB );                                               
                prochar( val128chrB, sizeof( val128chrB ) );                    
  state = BSTATE;                                                               
            }                                                                   
        }                                                                       
        else                                                                    
        {                                                                       
            /* Process the character in Code A */                               
            prochar( val128chrA, sizeof( val128chrA ) );                        
        }                                                                       
    }                                                                           
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                codeb - Process character when in Code B               */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void codeb( void )                                                       
{                                                                               
    /* How many digits are at current position */                               
    int numd = numdigits();                                                     
                                                                                
    /* If more than 4 digits then change to Code C */                           
    if ( numd >= 4 && numd % 2 == 0 )                                           
    {                                                                           
        insert( ZCODEC );                                                       
        state = CSTATE;                                                         
    }                                                                           
    else                                                                        
    {                                                                           
 /* Is current character a control character */                                 
        if ( nextsp( curr, curr ) == KCONTROL )                                 
        {                                                                       
            /* If next special is a lower case character */                     
            if ( nextsp( curr + 1, size ) == KLOWER )                           
            {                                                                   
                /* Shift for the one control letter */                          
                insert( ZSHIFT );                                               
                prochar( val128chrA, sizeof( val128chrA ) );                    
            }                                                                   
     else                                                                       
            {                                                                   
                /* If next special is also a control character */               
                                                                                
                /* Change to Code A for next characters */                      
                insert( ZCODEA );                                               
                prochar( val128chrA, sizeof( val128chrA ) );                    
                state = ASTATE;                                                 
     }                                                                          
        }                                                                       
        else                                                                    
        {                                                                       
            /* Process the character in Code B */                               
            prochar( val128chrB, sizeof( val128chrB ) );                        
        }                                                                       
    }                                                                           
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                codec - Process character when in Code C               */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void codec( void )                                                       
{                                                                               
    /* How many digits are at current position */                               
    int numd = numdigits();                                                     
    int combined;                                                               
                                                                                
    /* If 2 or more digits then change process the digits */                    
    if ( numd >= 2 )                                                            
    {                                                                           
        /* Get left digit of two digit pair */                                  
        /* Get right digit of two digit pair */                                 
        /* Combine the digits to one number  */                                 
 combined = CTOI( input[curr] ) * 10 + CTOI( input[curr + 1] );                 
 curr += 2;                                                                     
                                                                                
        insert( combined );                                                     
    }                                                                           
    else                                                                        
    {                                                                           
        /* Is current character a control character */                          
        if ( nextsp( curr, size ) == KCONTROL )                                 
        {                                                                       
            /* Change to Code A for next characters */                          
            insert( ZCODEA );                                                   
            state = ASTATE;                                                     
        }                                                                       
        else                                                                    
        {                                                                       
            /* Otherwise change to Code B for next characters */                
            insert( ZCODEB );                                                   
            state = BSTATE;                                                     
 }                                                                              
    }                                                                           
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*   match - Return index of first character in test that is in string   */     
/*-----------------------------------------------------------------------*/     
                                                                                
static int match( char *test, char *string, int lenstring, int start,           
                 int finish)                                                    
{                                                                               
    int i;                                                                      
                                                                                
    /* For every character to be tested */                                      
    for ( i = start; i < finish; i++ )                                          
    {                                                                           
        /* If this character is one trying to locate, return position */        
 if ( memchr( string, test[i], lenstring ) != NULL )                            
            return ( i );                                                       
    }                                                                           
    return ( -1 );                                                              
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*         nextsp - Determine next special character that occurs         */     
/*-----------------------------------------------------------------------*/     
                                                                                
static int nextsp( int start, int stop )                                        
{                                                                               
    int lower;                                                                  
    int contrl;                                                                 
                                                                                
    /* If stop start is longer than size return neither */                      
    if ( start > stop )                                                         
        return ( KNEITHER );                                                    
                                                                                
    /* Determine first position of control and lower case characters */         
    lower   = match( (char *) input, c128lower, ASIZE(c128lower), start, stop );
    contrl  = match( (char *) input, c128ctrl, ASIZE(c128ctrl), start, stop );  
                                                                                
    /* Return neither if no lowercase or control characters */                  
    if ( lower == -1 && contrl == -1 )                                          
        return ( KNEITHER );                                                    
                                                                                
    /* Return CONTROL if no lowercase characters */                             
    if ( lower == -1 )                                                          
        return ( KCONTROL );                                                    
                                                                                
    /* Return LOWER if no control characters */                                 
    if ( contrl == -1 )                                                         
        return ( KLOWER );                                                      
                                                                                
    /* Return LOWER if lowercase occured before control characters */           
    if ( lower < contrl )                                                       
        return ( KLOWER );                                                      
                                                                                
    /* Return CONTROL if control occured before lowercase characters */         
    return ( KCONTROL );                                                        
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*       numdigits - Determine number of digits at current position      */     
/*-----------------------------------------------------------------------*/     
                                                                                
static int numdigits( void )                                                    
{                                                                               
    int firstnom;                                                               
                                                                                
    /* locate first non-digit in input string */                                
    firstnom = verify( (char *) input + curr, size - curr, valdigits,           
   strlen( valdigits ) );                                                       
                                                                                
    /* If only digits, return length of string remaining */                     
    if ( firstnom == -1 )                                                       
        return ( size - curr );                                                 
                                                                                
    /* Else return the position of first non-digit minus one */                 
    return ( firstnom );                                                        
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*         insert - Add bar-space number to the c128encode array         */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void insert( int patternum )                                             
{                                                                               
    /* If positions available to add characters */                              
    if ( c128len < C128MAXL )                                                   
    {                                                                           
 /* Add nextchar to the array */                                                
 c128encode[c128len++] = patternum;                                             
                                                                                
        /* If it is the start pattern do not weight the value */                
        if ( c128len == 1 )                                                     
            c128check = patternum;                                              
        else                                                                    
            /* If it is a data character weight the value */                    
            c128check += ( c128len - 1 ) * patternum;                           
                                                                                
        /* Modulo the check digit to keep it small */                           
        c128check %= C128MOD;                                                   
    }                                                                           
    else                                                                        
    {                                                                           
        /* Add to counter to keep track of number desired to be added */        
        c128len++;                                                              
    }                                                                           
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*       prochar - Process the current character using proper code       */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void prochar( char *ttable, int ttablelen )                              
{                                                                               
    /* Insert the bar-space pattern number to use for this character */         
    /* Increment to next character */                                           
    insert( ch_index( ttable, input[curr++], ttablelen ) );                     
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*        Check digit routine for UPC, EAN and Interleaved 2 of 5        */     
/*                                                                       */     
/*                    CHECKSR - Calculate Check Digit                    */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void checksr( int weight )                                               
{                                                                               
    int chksum;         /* suma de chequeo del string de entrada */             
    int charnum;        /* contador del ciclo */                                
                                                                                
    for ( chksum = 0, charnum = size - 1; charnum > 0; charnum -= 2 )           
 chksum += CTOI( input[charnum] ) * weight + CTOI( input[charnum - 1] );        
                                                                                
    if ( charnum == 0 )                                                         
 chksum += CTOI( input[charnum] ) * weight;                                     
                                                                                
    input[size++] = ITOC( ( 10 - ( chksum % 10 ) ) % 10 );                      
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                 validate - Validates the bar code data                */     
/*-----------------------------------------------------------------------*/     
                                                                                
static int validate( char *valchars, int codeflag )                             
{                                                                               
    char    tempinput[40];                                                      
    int     ipos;                                                               
                                                                                
    /* Copy valid portion of input string into tempinput */                     
                                                                                
#ifdef __FOXPRO__                                                               
    _MemMove( (char *) tempinput, (char *) input, size );                       
#else                                                                           
    memcpy( (char *) tempinput, (char *) input, size );                         
#endif                                                                          
                                                                                
    /* If DEFAULTCODE Then convert blanks to 0 */                               
    if ( codeflag == DEFAULTCODE )                                              
        translate( tempinput, size, '0', ' ' );                                 
                                                                                
    /* Find location of first invalid character in input data */                
                                                                                
                                                                                
#ifdef __FOXPRO__                                                               
    if ( codeflag == FCODE128 )                                                 
      ipos = verify( (char *) tempinput, size, (char *) valchars, sizeof (val128
) );                                                                            
    else                                                                        
      ipos = verify( (char *) tempinput, size, (char *) valchars, _StrLen( (char
 *) valchars ) );                                                               
#else                                                                           
    if ( codeflag == FCODE128 )                                                 
      ipos = verify( (char *) tempinput, size, (char *) valchars, sizeof (val128
) );                                                                            
    else                                                                        
      ipos = verify( (char *) tempinput, size, (char *) valchars, strlen( (char 
*) valchars ) );                                                                
#endif                                                                          
                                                                                
    /* If there is an invalid character in the input then */                    
    if ( ipos != -1 )                                                           
    {                                                                           
 switch ( codeflag )                                                            
 {                                                                              
     case DEFAULTCODE:   errmsg( 2, ' ' );
    break;                                                                      
     case FCODE39:       errmsg( 3, input[ipos] );                              
    break;                                                                      
     case FCODE128:      errmsg( 13, input[ipos] );                             
            default:            break;                                          
        }                                                                       
    }                                                                           
    return ( ipos == -1 ? 1 : 0 );                                              
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*       genbin - Generate Generic Binary Encodings from parameters      */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void genbin( char *encoding, int encodlen, int spcvalue )                
{                                                                               
    int     barnum;                                                             
    int     lindex;                                                             
    char    cwide;                                                              
                                                                                
    /* For each module in the encoding do */                                    
    for ( barnum = 0; barnum < encodlen; barnum++ )                             
    {                                                                           
        /* If module is to represent a space then */                            
 cwide = ( ( barnum % 2 != spcvalue ) ? '0': '1' );                             
                                                                                
 /* Get module size to use from encoding array */                               
 lindex = CTOI( encoding[barnum] );                                             
                                                                                
        /* Add to binrepr the correct sizing and increase length */             
                                                                                
#ifdef __FOXPRO__                                                               
 _MemFill( binrepr + lenbinrepr, cwide, mlength[lindex] );                      
#else                                                                           
 memset( binrepr + lenbinrepr, cwide, mlength[lindex] );                        
#endif                                                                          
                                                                                
 lenbinrepr += mlength[lindex];                                                 
    }                                                                           
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*         srconv - Converts Binary Representation to Code Points        */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void srconv( void )                                                      
{                                                                               
    int             ibytes;                                                     
    int             ibits;                                                      
    unsigned char   hex;                                                        
    int             charnum;                                                    
                                                                                
    /* bytes = (length + 3)/4 */                                                
    ibytes = ( lenbinrepr + 3 ) / 4;                                            
                                                                                
    /* Determine number of bits not filled yet */                               
    ibits = ( ibytes * 4 ) - lenbinrepr;                                        
                                                                                
    /* Add spaces representation to binary representation if needed */          
    if ( ibits > 0 )                                                            
                                                                                
#ifdef __FOXPRO__                                                               
 _MemFill( binrepr + lenbinrepr, '0', ibits );                                  
#else                                                                           
 memset( binrepr + lenbinrepr, '0', ibits );                                    
#endif                                                                          
                                                                                
    /* For every hex digit in binary representation do */                       
    for ( charnum = 0; charnum < ibytes; charnum++ )                            
    {                                                                           
        hex = 0;                                                                
                                                                                
        /* Convert binary representation to hex digit */                        
 if ( binrepr[charnum * 4]     == '1' )                                         
     hex += 8;                                                                  
 if ( binrepr[charnum * 4 + 1] == '1' )                                         
     hex += 4;                                                                  
 if ( binrepr[charnum * 4 + 2] == '1' )                                         
     hex += 2;                                                                  
 if ( binrepr[charnum * 4 + 3] == '1' )                                         
     hex += 1;                                                                  
                                                                                
                                                                                
        /* Put codepoint in output string */                                    
 output [charnum] = tPuntosEBCDIC [hex];                                        
    }                                                                           
    /* Return length of output string */                                        
    size = ibytes;                                                              
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                 errmsg - General error message routine                */     
/*-----------------------------------------------------------------------*/     
                                                                                
static void errmsg( int inum, char ch )                                         
{                                                                               
    static char *msg[] = { "",                                                  
                           "NO SUCH BARCODE - ",                        /*  1 */
                           "INPUT STRING NOT NUMERIC - ",               /*  2 */
                           "CODE39  - UNKNOWN CHARACTER - ",            /*  3 */
                           "MSI LENGTH GREATER THAN 15 - ",             /*  4 */
                           "CODE39 LENGTH GREATER THAN 30 - ",          /*  5 */
                           "CODE39 LENGTH GREATER THAN 14 - ",          /*  6 */
                           "2 OF 5 LENGTH GREATER THAN 40 - ",          /*  7 */
                           "2 OF 5 LENGTH GREATER THAN 20 - ",          /*  8 */
                           "2 OF 5 LENGTH GREATER THAN 35 - ",          /*  9 */
                           "LENGTH OF EAN-INPUT NOT 7,8,12 OR 13",      /* 10 */
      "LENGTH OF UPC-INPUT NOT 11",                /* 11 */                     
                           "UPC E ZERO SUPPRESSION NUMBER IS INVALID",  /* 12 */
                           "CODE128  - UNKNOWN CHARACTER - ",           /* 13 */
                           "CODE128 LENGTH GREATER THAN 28 - ",         /* 14 */
                           "LENGTH OF UPCE-1 - INPUT NOT 6" };          /* 15 */
    int len;                                                                    
                                                                                
#ifdef __FOXPRO__                                                               
    _StrCpy( (char *) output, "ERROR - " );                                     
#else                                                                           
    strcpy( (char *) output, "ERROR - " );                                      
#endif                                                                          
                                                                                
    strcat( (char *) output, (char *) msg[inum] );                              
                                                                                
    switch ( inum )                                                             
    {                                                                           
        case  1:    ch              = barcode;                                  
        case  3:                                                                
                                                                                
        case 13:                                                                
                                                                                
#ifdef __FOXPRO__                                                               
      len             = _StrLen( (char *) output );                             
#else                                                                           
      len             = strlen( (char *) output );                              
#endif                                                                          
                                                                                
      output[len]     = ch;                                                     
      output[++len]   = '\0';                                                   
      break;                                                                    
 case  2:    strcat( (char *) output, (char *) input );                         
      break;                                                                    
 case  4:                                                                       
 case  5:                                                                       
 case  6:                                                                       
 case  7:                                                                       
 case  8:                                                                       
        case  9:                                                                
        case 14:                                                                
                                                                                
#ifdef __FOXPRO__                                                               
      _itoa( size, (char *) output + _StrLen( (char *) output ), 1              
0 );                                                                            
#else                                                                           
      _itoa( size, (char *) output + strlen( (char *) output ), 10              
 );                                                                             
#endif                                                                          
                                                                                
        default:    break;                                                      
    }                                                                           
    size = ERRCODE;                                                             
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                                                                       */     
/*    Functions reimplemented from the PL/I runtime library              */     
/*                                                                       */     
/*-----------------------------------------------------------------------*/     
                                                                                
/*-----------------------------------------------------------------------*/     
/*   _itoa - Convert an integer to a displayable character               */     
/*   NOTE: in many C compilers this is already part of the libraries     */     
/*-----------------------------------------------------------------------*/     
                                                                                
#ifndef _itoa                                                                   
#ifndef itoa                                                                    
                                                                                
#define BUFSIZE         ( sizeof( int ) * 8 + 1 )                               
                                                                                
static char *_itoa( int n, char *str, int base )                                
{                                                                               
    int             i = 2;                                                      
    int             uarg;                                                       
    char            *tail;                                                      
    char            *head = str;                                                
    char            buf[BUFSIZE];                                               
    div_t           r;                                                          
                                                                                
                                                                                
    if ( base < 2 || base > 36 )                                                
    {                                                                           
        *str = '\0';                                                            
        return ( str );                                                         
    }                                                                           
                                                                                
    tail = &buf[BUFSIZE - 1];                                                   
    *tail-- = '\0';                                                             
                                                                                
    if ( base == 10 && n < 0 )                                                  
    {                                                                           
        *head++ = '-';                                                          
        uarg    = -n;                                                           
    }                                                                           
    else                                                                        
        uarg = n;                                                               
                                                                                
    if (uarg)                                                                   
    {                                                                           
        for ( i = 1; uarg; ++i )                                                
        {                                                                       
            r       = div( uarg, base );                                        
            *tail-- = (char) ( r.rem + ( ( 9L < r.rem ) ?                       
                                         ('A' - 10 ) : '0' ) );                 
            uarg    = r.quot;                                                   
        }                                                                       
    }                                                                           
    else                                                                        
 *tail-- = '0';                                                                 
                                                                                
#ifdef __FOXPRO__                                                               
    _MemMove( head, ++tail, i );                                                
#else                                                                           
    memcpy( head, ++tail, i );                                                  
#endif                                                                          
                                                                                
    return ( str );                                                             
}                                                                               
                                                                                
#undef BUFSIZE                                                                  
#endif  /* itoa */                                                              
#endif  /* _itoa */                                                             
                                                                                
/*-----------------------------------------------------------------------*/     
/*     translate - Replace an octal character with a string              */     
/*-----------------------------------------------------------------------*/     
                                                                                
static char *translate( char *trans, int len, char after, char before )         
{                                                                               
    char *start;                                                                
    char *end;                                                                  
                                                                                
    for ( start = trans, end = trans + len; start < end; start++ )              
        if ( *start == before )                                                 
            *start = after;                                                     
                                                                                
    return ( trans );                                                           
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/* verify - Verify that all the characters in the first string are       */     
/* also in the second. Return the first posision in the second string    */     
/* relative to the first where this is not true. If all of the chars     */     
/* are in the second string return -1                                    */     
/*-----------------------------------------------------------------------*/     
                                                                                
static int verify( char *check, int checklen, char *src, int srclen )           
{                                                                               
    char *start;                                                                
    char *end;                                                                  
                                                                                
    for ( start = check, end = check + checklen; start < end; start++ )         
 if ( memchr( src, *start, srclen ) == NULL )                                   
            break;                                                              
                                                                                
    return ( start < end ? start - check : -1 );                                
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/* Return the position in the string where the character is first found  */     
/*-----------------------------------------------------------------------*/     
                                                                                
static int ch_index( char *buf, char c, int count )                             
{                                                                               
#ifndef MVS                                                                     
    char *found = memchr( buf, c, count );                                      
#else                                                                           
    char *found = (char*) memchr( buf, c, count );                              
#endif                                                                          
                                                                                
    return ( found != NULL ? found - buf : -1 );                                
}                                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*                                                                       */     
/*        Some special functions if you are using FoxPro compiler        */     
/*                                                                       */     
/*-----------------------------------------------------------------------*/     
                                                                                
#ifdef __FOXPRO__                                                               
                                                                                
/*-----------------------------------------------------------------------*/     
/*  FBARCODE( <cType>, <cInput> ) --> cOutput                            */     
/*-----------------------------------------------------------------------*/     
                                                                                
void FAR fbarcode( ParamBlk FAR *param )                                        
{                                                                               
    char        btype;                                                          
    char        *input;                                                         
    char        *output;                                                        
    MHANDLE     mh_out;                                                         
    char        buf[128];                                                       
    int         size = 128;                                                     
    int         num;                                                            
                                                                                
    if ( param->pCount < 2 )                                                    
        _StrCpy( buf, "ERROR - INSUFFICIENT PARAMETERS" );                      
    else                                                                        
    {                                                                           
 if ( param->p[( num = 0 )].val.ev_type != 'C' ||                               
      param->p[( num = 1 )].val.ev_type != 'C' )                                
 {                                                                              
     _StrCpy( buf, "ERROR - INVALID TYPE IN PARAMETER " );                      
     _itoa( num, buf + strlen( buf ), 10 );                                     
 }                                                                              
 else                                                                           
        {                                                                       
     btype   = *( (char *) _HandToPtr( param->p[0].val.ev_handle ) );           
     size    = param->p[1].val.ev_length;                                       
     input   = _HandToPtr( param->p[1].val.ev_handle );                         
     size    = eansrc( btype, input, size, buf );                               
 }                                                                              
    }                                                                           
                                                                                
    if ( size != 128 && ( mh_out = _AllocHand( size + 1 ) ) == 0 )              
 _Error( 182 );          /* Insufficient memory */                              
                                                                                
    output = _HandToPtr( mh_out );                                              
                                                                                
    _MemMove( output, buf, size );                                              
    output[size] = '\0';                                                        
                                                                                
    _HLock( mh_out );           /* Lock MHANDLE during callback. */             
    _RetChar( output );                                                         
                                                                                
    _FreeHand( mh_out );        /* Free MHANDLEs we allocate, but not handles   
                                   passed in ParamBlk. */                       
}                                                                               
                                                                                
FoxInfo     myFoxInfo[] = { { "FBARCODE", (FPFI) fbarcode, 2, "C,C" } };        
                                                                                
FoxTable    _FoxTable   = {                                                     
    (FoxTable FAR *) 0, sizeof( myFoxInfo ) / sizeof( FoxInfo ), myFoxInfo      
};                                                                              
                                                                                
#endif /* __FOXPRO__ */                                                         
